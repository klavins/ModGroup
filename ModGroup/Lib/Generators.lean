/- # SL2 is generated by T and S

This file will eventually contain the solution to exercies 1.1.1 of [Diamond and Shurman](https://public.websites.umich.edu/~hlm/nzm/modgp.pdf). The solution is elucidated a bit more clearly in [Brubaker's Notes](https://math.mit.edu/~brubaker/Math784/modular.pdf).

Given M : SL2, we want to show there exists a way to write it as

    M = A₁A₂⬝ ... ⬝ Aₙ

where Aᵢ is either T, T⁻¹, S or S⁻¹. We can do this by factoring M. That is, if M is not already equal to T, T⁻¹, S or S⁻¹, then we show that M = XY where X and Y are in SL2. And we continue recursively until X and Y are one of T, T⁻¹, S or S⁻¹.

So, given M, how do we find Y? We could guess it is one of T, T⁻¹, S or S⁻¹, and choose one that gives X : SL2.

For example, suppose M = !![2,1;1,1]. We would solve each XY for X and see which one gives |X|=1.

One issue is that you can always put, for example, M = M*S*S⁻¹ = (MS)*S⁻¹. So we need to also specify that X ≤ M in some way. The book suggests using |c| as a decreasing element. So the goal is to find X and Y so that |X₁₀| < |M₁₀| and Y is a known element of SL2.

-/

import ModGroup.Lib.SL2
import ModGroup.Lib.FLT

/- Generators of SL2 -/
def T := SL2.mk !![1,1;0,1]
def S := SL2.mk !![0, -1; 1, 0]

#eval (S.val)^4
#eval (S.val*T.val)^6

#check T^(-3:ℤ)

theorem s_sq_1 : (sl2_to_fl S) ∘ (sl2_to_fl S) = fl_one := by
  funext ⟨ z, hp ⟩
  simp[S,sl2_to_fl,fl_map,fl_one_inst,fl_one]

theorem s_sq_1' : (sl2_to_fl S) * (sl2_to_fl S) = fl_one := by
  simp[fl_hmul_inst,fl_comp]
  simp[sl2_to_fl,fl_map,fl_one_inst,fl_one]
  rw[S]


/- Example : This calculation is from Brubaker. -/

namespace Example

def M1 : SL2 := ⟨ !![ 4, 9; 11, 25 ], by decide ⟩
def M2 : SL2 := ⟨ !![ 1, -4; 3, -11 ], by decide ⟩

/- Step one, figure out how many T⁻¹s to use. -/
example : M1 * T⁻¹ * T⁻¹ * S = M2 := by
  simp[M1,M2,T,S,Matrix.inv]

/- Step two, solve for M1. Then M2 < M1 and you can continue with M2. Note that we know M2 : SL2 because the determinant of a product is the product of a determinant. -/
example : M1 = M2 * S⁻¹ * T * T:= by
  simp[M1,M2,T,S,Matrix.inv]

end Example

/- Simplified version of T^n-/
def Tpow (n:ℤ ) : SL2 := ⟨ !![1,n;0,1], by simp ⟩

/- Useful intermediate matrix -/
def MTpow (M : Matrix (Fin 2) (Fin 2) ℤ) (n:ℤ) : Matrix (Fin 2) (Fin 2) ℤ  :=
  !![ M 0 0, (M 0 0)*n + M 0 1;
      M 1 0, (M 1 0)*n + M 1 1 ]

/- T^n : SL2 can be simplified to Tpow -/
theorem Tz {n:ℤ} : T^n = Tpow n := by
  unfold Tpow
  by_cases hn : n ≥ 0
  . let m : Nat := Int.toNat n
    have : m = n := by exact Int.toNat_of_nonneg hn
    rw[←this]
    induction m with
    | zero => simp[this]; exact Matrix.one_fin_two
    | succ k ih =>
      have up_dist : ((k:ℤ)+1) = ↑(k+1) := rfl
      have : T^((k:ℤ)+1) = T^(k:ℤ) * T := rfl
      rw[←up_dist,this,ih,T]
      simp[add_comm]

  . have : n < 0 := by exact Int.lt_of_not_ge hn
    let m := -n
    have hm : m > 0 := by exact Int.neg_pos_of_neg this
    have : -m = n := by exact Int.neg_neg n
    rw[←this]
    let k : Nat := Int.toNat m
    have : k = m := by apply Int.toNat_of_nonneg; exact Int.le_of_lt hm
    rw[←this]
    induction k with
    | zero => simp; exact Matrix.one_fin_two
    | succ j ih =>
      have up_dist : -((j:ℤ)+1) = -↑(j+1) := rfl
      have : T^(-((j:ℤ)+1)) = T^(-j:ℤ) * T⁻¹ := by group
      rw[←up_dist,this,ih,T]
      simp[Matrix.inv,add_comm]

theorem asd : T = T.val := rfl

/- Helpful Identity -/
theorem mt_pow {M : Matrix (Fin 2) (Fin 2) ℤ} {n:ℤ} : M * (T^n:SL2) = MTpow M n := by
    unfold MTpow
    rw[Tz,Tpow,Matrix.eta_fin_two M]
    simp

theorem shrinkable (M:SL2) (c : ℤ): c ≠ 0 → ∃ n : ℤ, (M * T^n) 1 0 = c ∧ |(M * T^n) 1 1| < |c|/2 := by
  intro hc
  dsimp
  sorry
